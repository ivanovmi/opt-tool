import errno
import os


def make_directory(dir_name):
    print('Creating directory with name {}...'.format(dir_name))
    try:
        os.makedirs(dir_name)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


def create_empty_class(class_name):
    tab_sign = ' ' * 4
    new_class = "class {}(object):\n{}pass".format(class_name.title(),
                                                   tab_sign)
    print('Creating file with empty class {}...'.format(class_name))
    return new_class


def create_class_with_method(class_name):
    new_class = list()
    tab_sign = ' ' * 4
    new_class.append("class {}(object):".format(list(
        class_name.keys())[0].title()))
    for value in class_name.values():
        for func_name in value:
            new_class.append("{}def {}(self):\n{}{}pass".format(tab_sign,
                                                                func_name,
                                                                tab_sign,
                                                                tab_sign))
    print('Creating file with class {} with methods {}...'.format(
        list(class_name.keys())[0].title(), str(list(class_name.values()))))

    return '\n\n'.join(new_class)


def generate_entity(pkg_name, dir_name):
    for entity in pkg_name:
        if isinstance(entity, dict):
            new_class = create_class_with_method(entity)
            entity_name = list(entity.keys())[0]
        else:
            new_class = create_empty_class(entity)
            entity_name = entity
        filename = dir_name + '/' + entity_name + '.py'
        with open(filename, 'w+') as f:
            f.write(new_class + '\n')


def generate_init(dir_name):
    filename = str(dir_name) + '/' + '__init__.py'
    with open(filename, 'w+'):
        print('Creating init file in package {}...'.format(dir_name))


def generate_packages(pkg_name, dir_name=''):
    if isinstance(pkg_name, list):
        for el in pkg_name:
            generate_packages(pkg_name[pkg_name.index(el)], dir_name)
    else:
        if pkg_name is not None:
            for pkg in pkg_name:
                if isinstance(pkg, dict):
                    pkg = list(pkg.keys())[0]
                if pkg != 'entity':
                    dir_n = dir_name + '/' + str(pkg)
                    make_directory(dir_n)
                    generate_packages(pkg_name[pkg], dir_n)
                    generate_init(dir_n)
                else:
                    dir_n = dir_name
                    generate_entity(pkg_name[pkg], dir_n)


def generate_setup(pkg, dir_name):
    with open(dir_name + '/' + 'README.rst', 'w+') as readme_file:
        print('Creating README file for package {}...'.format(
            str(pkg['name'])))
        string = str(pkg['name']) + '\n' + '=' * len(str(pkg['name']))
        readme_file.write(string)
    with open(dir_name + '/' + 'setup.cfg', 'w+') as setup_cfg:
        print('Creating setup.cfg for package {}...'.format(str(pkg['name'])))
        string = '''[metadata]
name = {}
description-file =
    README.rst
author = <GENERATED BY OPT-TOOL>
classifier =
    Environment :: OpenStack
    Operating System :: POSIX :: Linux
    Programming Language :: Python
    Programming Language :: Python :: 2
    Programming Language :: Python :: 2.7'''.format(str(pkg['name']))
        setup_cfg.write(string)

    with open(dir_name + '/' + 'setup.py', 'w+') as setup_py:
        print('Creating setup.py for package {}...'.format(str(pkg['name'])))
        string = '''import setuptools

# In python < 2.7.4, a lazy loading of package `pbr` will break
# setuptools if some other modules registered functions in `atexit`.
# solution from: http://bugs.python.org/issue15881#msg170215
try:
    import multiprocessing  # noqa
except ImportError:
    pass

setuptools.setup(
    setup_requires=['pbr>=2.0.0'],
    pbr=True)\n'''
        setup_py.write(string)


def generate_directories(config):
    for package in config.packages:
        _dir = str(config.output_dir) + str(package['name'])
        make_directory(_dir)
        generate_setup(package, _dir)
        if package['components']:
            for component in package['components']:
                generate_packages(component, _dir)
